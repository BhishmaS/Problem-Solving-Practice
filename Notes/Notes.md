## Sliding Window
	- for() { while() }
	- single prefix sum, all prefixes sums in array
	- max or min find

## Tree
	- Inorder, preorder, postorder (Recursive, iterative)
	- DFS, BFS
	- going to the left leaf end or right leaf end and traversing total tree based on the problem

## Two Pointer
	- Ignoring extra space
	- May be sliding window, may be binary search
	- Searching pairs...

## Bit Manipulation
	- Magical reduction of time complexity
	- Rolling hash

## Graph
	- Union Find (For regions)
	- 



-----------------------------------------------------------------
### For Reference:

If an input array is sorted then
  - Binary search
  - Two pointers

If asked for all permutations/subsets then
  - Backtracking

If given a tree then
  - DFS
  - BFS

If given a graph then
  - DFS
  - BFS

If given a linked list then
  - Two pointers

If recursion is banned then
  - Stack

If must solve in-place then
  - Swap corresponding values
  - Store one or more different values in the same pointer

If asked for maximum/minumum subarray/subset/options then
  - Greedy
  - Dynamic programming

If asked for top/least K items then
  - Heap

If asked for common strings then
  - Map
  - Trie

Else
  - Map/Set for O(1) time & O(n) space
  - Sort input for O(nlogn) time and O(1) space


--------------------------------------------------------------

# General Algorithm:
1. Euclid's Algorithm
2. Union Find Algorithm
3. Huffman Algorithm

# Arrays:
1. Kadane's Algorithm
2. Floy's Cycle Detection
3. KMP Algo
4. Quick Select Algo
5. Boyer Algo

# Graphs:
1. Kruskal Algo
2. Dijkstra's
3. Bellman-Ford
4. Topological Sort
5. Floyd Warshall
6. Flood Fill
7. Lee

# Searching:
1. Linear Search
2. Jump Search
3. Binary Search
4. DFS
5. BFS